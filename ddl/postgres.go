package ddl

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"github.com/Tsarbomba69-com/mammoth.server/models"
	"github.com/Tsarbomba69-com/mammoth.server/utils"
	"gorm.io/gorm"
)

// postgresql_ddl.go
type PostgreSQLDDL struct{} // Empty struct since we don't need state

func (p PostgreSQLDDL) CreateSchemaSQL(schemaName string) string {
	return fmt.Sprintf("CREATE SCHEMA IF NOT EXISTS %s;\n", quoteIdentifier(schemaName))
}

func (p PostgreSQLDDL) DropSchemaSQL(schema string) string {
	return fmt.Sprintf("DROP SCHEMA IF EXISTS %s CASCADE;\n", quoteIdentifier(schema))
}

func (p PostgreSQLDDL) CreateTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE %s.%s (\n", quoteIdentifier(tableDiff.SchemaName), quoteIdentifier(tableDiff.Name)))

	// Add columns
	for i, col := range append(tableDiff.ColumnsSame, tableDiff.ColumnsAdded...) {
		if i > 0 {
			sql.WriteString(",\n")
		}
		sql.WriteString(fmt.Sprintf("  %s %s", quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
	}

	// Add primary keys
	var pkColumns []string
	for _, col := range append(tableDiff.ColumnsSame, tableDiff.ColumnsAdded...) {
		if col.IsPrimary {
			pkColumns = append(pkColumns, quoteIdentifier(col.Name))
		}
	}
	if len(pkColumns) > 0 {
		sql.WriteString(fmt.Sprintf(",\n  PRIMARY KEY (%s)", strings.Join(pkColumns, ", ")))
	}

	sql.WriteString("\n);\n")

	// Add indexes
	for _, idx := range append(tableDiff.IndexesSame, tableDiff.IndexesAdded...) {
		if !idx.IsPrimary { // Primary key already handled
			sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
		}
	}

	return sql.String()
}

func (p PostgreSQLDDL) AlterTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	tableName := quoteIdentifier(tableDiff.Name)
	schemaName := quoteIdentifier(tableDiff.SchemaName)

	// Add columns
	for _, col := range tableDiff.ColumnsAdded {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s ADD COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
		// if col.IsAutoIncrement {
		// 	sql.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
		// }
		sql.WriteString(";\n")
	}

	// Drop columns
	for _, col := range tableDiff.ColumnsRemoved {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s DROP COLUMN %s;\n",
			schemaName, tableName, quoteIdentifier(col.Name)))
	}

	// Modify columns
	for _, change := range tableDiff.ColumnsModified {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s MODIFY COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(change.Name), change.Target.DataType))
		if !change.Target.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if change.Target.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", change.Target.Default))
		}
		sql.WriteString(";\n")
	}

	// Add indexes
	for _, idx := range tableDiff.IndexesAdded {
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Drop indexes
	for _, idx := range tableDiff.IndexesRemoved {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Modify indexes (drop and recreate)
	for _, change := range tableDiff.IndexesModified {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Source))
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Target))
	}

	// Modify foreign key (drop and recreate)
	for _, change := range tableDiff.ForeignKeyModified {
		sql.WriteString(p.DropForeignKeySQL(schemaName, tableDiff.Name, change.Source.Name))
		sql.WriteString(p.AddForeignKeySQL(schemaName, tableDiff.Name, change.Target))
	}

	return sql.String()
}

func (p PostgreSQLDDL) RevertAlterTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	tableName := quoteIdentifier(tableDiff.Name)
	schemaName := quoteIdentifier(tableDiff.SchemaName)

	// Revert added columns (drop them)
	for _, col := range tableDiff.ColumnsAdded {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s DROP COLUMN %s;\n",
			schemaName, tableName, quoteIdentifier(col.Name)))
	}

	// Revert removed columns (add them back)
	for _, col := range tableDiff.ColumnsRemoved {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s ADD COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
		sql.WriteString(";\n")
	}

	// Revert column modifications
	for _, change := range tableDiff.ColumnsModified {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s MODIFY COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(change.Name), change.Source.DataType))
		if !change.Source.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if change.Source.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", change.Source.Default))
		}
		sql.WriteString(";\n")
	}

	// Revert added indexes (drop them)
	for _, idx := range tableDiff.IndexesAdded {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Revert removed indexes (add them back)
	for _, idx := range tableDiff.IndexesRemoved {
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Revert modified indexes
	for _, change := range tableDiff.IndexesModified {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Target))
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Source))
	}

	return sql.String()
}

func (p PostgreSQLDDL) CreateIndexSQL(schemaName, tableName string, idx models.Index) string {
	if idx.IsPrimary {
		return "" // Already handled in CREATE TABLE
	}

	indexType := "INDEX"
	if idx.IsUnique {
		indexType = "UNIQUE INDEX"
	}

	quotedColumns := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		quotedColumns[i] = quoteIdentifier(col)
	}

	return fmt.Sprintf("CREATE %s %s ON %s.%s (%s);\n",
		indexType,
		quoteIdentifier(idx.Name),
		quoteIdentifier(schemaName),
		quoteIdentifier(tableName),
		strings.Join(quotedColumns, ", "))
}

func (p PostgreSQLDDL) DropIndexSQL(schemaName, tableName string, idx models.Index) string {
	if idx.IsPrimary {
		return fmt.Sprintf("ALTER TABLE %s.%s DROP CONSTRAINT %s;\n",
			quoteIdentifier(schemaName),
			quoteIdentifier(tableName),
			quoteIdentifier(idx.Name))
	}
	return fmt.Sprintf("DROP INDEX %s;\n", quoteIdentifier(idx.Name))
}

func (p PostgreSQLDDL) DropTableSQL(schemaName, tableName string) string {
	return fmt.Sprintf("DROP TABLE %s.%s;\n", quoteIdentifier(schemaName), quoteIdentifier(tableName))
}

func quoteIdentifier(name string) string {
	return fmt.Sprintf("\"%s\"", name)
}

func joinIdentifiers(cols []string) string {
	var parts []string
	for _, col := range cols {
		parts = append(parts, quoteIdentifier(col))
	}
	return strings.Join(parts, ", ")
}

func (p PostgreSQLDDL) AddForeignKeySQL(schemaName, table string, fk models.ForeignKey) string {
	cols := joinIdentifiers(fk.Columns)
	refCols := joinIdentifiers(fk.ReferencedColumns)

	return fmt.Sprintf(`ALTER TABLE %s.%s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s.%s (%s) ON DELETE %s ON UPDATE %s;`,
		quoteIdentifier(schemaName),
		quoteIdentifier(table),
		quoteIdentifier(fk.Name),
		cols,
		quoteIdentifier(schemaName), // TODO: use fk.ReferencedSchema if available
		quoteIdentifier(fk.ReferencedTable),
		refCols,
		fk.OnDelete,
		fk.OnUpdate)
}

func (p PostgreSQLDDL) DropForeignKeySQL(schemaName, table, constraint string) string {
	return fmt.Sprintf("ALTER TABLE %s.%s DROP CONSTRAINT %s;\n", quoteIdentifier(schemaName), quoteIdentifier(table), quoteIdentifier(constraint))
}

func (p PostgreSQLDDL) DumpDatabaseSQL(connection models.DBConnection, db *gorm.DB) (string, error) {
	var out bytes.Buffer
	var stderr bytes.Buffer
	pass, err := utils.Decrypt([]byte([]byte(os.Getenv("ENCRYPTION_KEY"))), connection.Password)
	if err != nil {
		return "", fmt.Errorf("failed to decrypt password: %v", err)
	}

	err = os.Setenv("PGPASSWORD", pass) // Set the password for pg_dump
	if err != nil {
		return "", fmt.Errorf("failed to set PGPASSWORD: %v", err)
	}

	cmd := exec.Command("pg_dump",
		"-h", connection.Host,
		"-U", connection.User,
		"-d", connection.DBName,
		"-F", "t",
		"-v",
	)
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("pg_dump failed: %v - %s", err, stderr.String())
	}

	return out.String(), nil
}

func (p PostgreSQLDDL) CreateSequenceSQL(seq models.Sequence) string {
	var parts []string

	// Basic sequence creation
	parts = append(parts, fmt.Sprintf("CREATE SEQUENCE %s.%s",
		quoteIdentifier(seq.SchemaName),
		quoteIdentifier(seq.Name)))

	// Add sequence parameters if they are set
	if seq.Increment != 0 {
		parts = append(parts, fmt.Sprintf("INCREMENT BY %d", seq.Increment))
	}
	if seq.MinValue != 0 {
		parts = append(parts, fmt.Sprintf("MINVALUE %d", seq.MinValue))
	}
	if seq.MaxValue != 0 {
		parts = append(parts, fmt.Sprintf("MAXVALUE %d", seq.MaxValue))
	}
	if seq.StartValue != 0 {
		parts = append(parts, fmt.Sprintf("START WITH %d", seq.StartValue))
	}
	if seq.IsCyclic {
		parts = append(parts, "CYCLE;\n")
	} else {
		parts = append(parts, "NO CYCLE;\n")
	}

	if seq.OwnedByTable != "" && seq.OwnedByColumn != "" {
		parts = append(parts,
			fmt.Sprintf(
				"ALTER SEQUENCE %s.%s OWNED BY %s.%s;\n",
				quoteIdentifier(seq.SchemaName),
				quoteIdentifier(seq.Name),
				quoteIdentifier(seq.OwnedByTable),
				quoteIdentifier(seq.OwnedByColumn),
			))
	}

	return strings.Join(parts, " ")
}

func (p PostgreSQLDDL) DropSequenceSQL(schemaName string, name string) string {
	return fmt.Sprintf("DROP SEQUENCE IF EXISTS %s.%s;\n", quoteIdentifier(schemaName), quoteIdentifier(name))
}

// AlterSequenceSQL generates the SQL to alter a sequence based on the changes detected
func (p PostgreSQLDDL) AlterSequenceSQL(seqChange models.SequenceChange) string {
	return alterSequece(seqChange, seqChange.Target)
}

// RevertAlterSequenceSQL generates the SQL to revert a sequence alteration
func (p PostgreSQLDDL) RevertAlterSequenceSQL(seqChange models.SequenceChange) string {
	return alterSequece(seqChange, seqChange.Source)
}

func alterSequece(seqChange models.SequenceChange, seq models.Sequence) string {
	var clauses []string

	for _, attr := range seqChange.ChangedAttr {
		switch attr {
		case "increment":
			clauses = append(clauses, fmt.Sprintf("INCREMENT BY %d", seq.Increment))
		case "start_value":
			clauses = append(clauses, fmt.Sprintf("START WITH %d", seq.StartValue))
		case "min_value":
			clauses = append(clauses, fmt.Sprintf("MINVALUE %d", seq.MinValue))
		case "max_value":
			if seq.MaxValue == 0 {
				clauses = append(clauses, "NO MAXVALUE")
			} else {
				clauses = append(clauses, fmt.Sprintf("MAXVALUE %d", seq.MaxValue))
			}
		case "is_cyclic":
			if seq.IsCyclic {
				clauses = append(clauses, "CYCLE")
			} else {
				clauses = append(clauses, "NO CYCLE")
			}
		// case "cache":
		// 	clauses = append(clauses, fmt.Sprintf("CACHE %d", seq.Cache))
		case "OwnedByTable", "OwnedByColumn":
			if seq.OwnedByTable != "" && seq.OwnedByColumn != "" {
				clauses = append(clauses, fmt.Sprintf("OWNED BY \"%s\".\"%s\"",
					seq.OwnedByTable, seq.OwnedByColumn))
			} else {
				clauses = append(clauses, "OWNED BY NONE")
			}
		}
	}

	if len(clauses) == 0 {
		return ""
	}

	return fmt.Sprintf("ALTER SEQUENCE \"%s\".\"%s\" %s;\n",
		seq.SchemaName, seq.Name, strings.Join(clauses, " "))
}

package ddl

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"

	"github.com/Tsarbomba69-com/mammoth.server/models"
	"github.com/Tsarbomba69-com/mammoth.server/utils"
	"gorm.io/gorm"
)

// postgresql_ddl.go
type PostgreSQLDDL struct{} // Empty struct since we don't need state

func (p PostgreSQLDDL) CreateSchemaSQL(schemaName string) string {
	return fmt.Sprintf("CREATE SCHEMA IF NOT EXISTS %s;\n", quoteIdentifier(schemaName))
}

func (p PostgreSQLDDL) DropSchemaSQL(schema string) string {
	return fmt.Sprintf("DROP SCHEMA IF EXISTS %s CASCADE;\n", quoteIdentifier(schema))
}

func (p PostgreSQLDDL) CreateTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	sql.WriteString(fmt.Sprintf("CREATE TABLE %s.%s (\n", quoteIdentifier(tableDiff.SchemaName), quoteIdentifier(tableDiff.Name)))

	// Add columns
	for i, col := range append(tableDiff.ColumnsSame, tableDiff.ColumnsAdded...) {
		if i > 0 {
			sql.WriteString(",\n")
		}
		sql.WriteString(fmt.Sprintf("  %s %s", quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
	}

	// Add primary keys
	var pkColumns []string
	for _, col := range append(tableDiff.ColumnsSame, tableDiff.ColumnsAdded...) {
		if col.IsPrimary {
			pkColumns = append(pkColumns, quoteIdentifier(col.Name))
		}
	}
	if len(pkColumns) > 0 {
		sql.WriteString(fmt.Sprintf(",\n  PRIMARY KEY (%s)", strings.Join(pkColumns, ", ")))
	}

	sql.WriteString("\n);\n")

	// Add indexes
	for _, idx := range append(tableDiff.IndexesSame, tableDiff.IndexesAdded...) {
		if !idx.IsPrimary { // Primary key already handled
			sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
		}
	}

	return sql.String()
}

func (p PostgreSQLDDL) AlterTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	tableName := quoteIdentifier(tableDiff.Name)
	schemaName := quoteIdentifier(tableDiff.SchemaName)

	// Add columns
	for _, col := range tableDiff.ColumnsAdded {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s ADD COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
		// if col.IsAutoIncrement {
		// 	sql.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
		// }
		sql.WriteString(";\n")
	}

	// Drop columns
	for _, col := range tableDiff.ColumnsRemoved {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s DROP COLUMN %s;\n",
			schemaName, tableName, quoteIdentifier(col.Name)))
	}

	// Modify columns
	for _, change := range tableDiff.ColumnsModified {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s MODIFY COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(change.Name), change.Target.DataType))
		if !change.Target.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if change.Target.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", change.Target.Default))
		}
		sql.WriteString(";\n")
	}

	// Add indexes
	for _, idx := range tableDiff.IndexesAdded {
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Drop indexes
	for _, idx := range tableDiff.IndexesRemoved {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Modify indexes (drop and recreate)
	for _, change := range tableDiff.IndexesModified {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Source))
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Target))
	}

	// Modify foreign key (drop and recreate)
	for _, change := range tableDiff.ForeignKeyInfoModified {
		sql.WriteString(p.DropForeignKeySQL(schemaName, tableDiff.Name, change.Source.Name))
		sql.WriteString(p.AddForeignKeySQL(schemaName, tableDiff.Name, change.Target))
	}

	return sql.String()
}

func (p PostgreSQLDDL) RevertAlterTableSQL(tableDiff models.TableDiff) string {
	var sql strings.Builder
	tableName := quoteIdentifier(tableDiff.Name)
	schemaName := quoteIdentifier(tableDiff.SchemaName)

	// Revert added columns (drop them)
	for _, col := range tableDiff.ColumnsAdded {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s DROP COLUMN %s;\n",
			schemaName, tableName, quoteIdentifier(col.Name)))
	}

	// Revert removed columns (add them back)
	for _, col := range tableDiff.ColumnsRemoved {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s ADD COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(col.Name), col.DataType))
		if !col.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if col.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", col.Default))
		}
		sql.WriteString(";\n")
	}

	// Revert column modifications
	for _, change := range tableDiff.ColumnsModified {
		sql.WriteString(fmt.Sprintf("ALTER TABLE %s.%s MODIFY COLUMN %s %s",
			schemaName, tableName, quoteIdentifier(change.Name), change.Source.DataType))
		if !change.Source.IsNullable {
			sql.WriteString(" NOT NULL")
		}
		if change.Source.Default != "" {
			sql.WriteString(fmt.Sprintf(" DEFAULT %s", change.Source.Default))
		}
		sql.WriteString(";\n")
	}

	// Revert added indexes (drop them)
	for _, idx := range tableDiff.IndexesAdded {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Revert removed indexes (add them back)
	for _, idx := range tableDiff.IndexesRemoved {
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, idx))
	}

	// Revert modified indexes
	for _, change := range tableDiff.IndexesModified {
		sql.WriteString(p.DropIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Target))
		sql.WriteString(p.CreateIndexSQL(tableDiff.SchemaName, tableDiff.Name, change.Source))
	}

	return sql.String()
}

func (p PostgreSQLDDL) CreateIndexSQL(schemaName, tableName string, idx models.IndexInfo) string {
	if idx.IsPrimary {
		return "" // Already handled in CREATE TABLE
	}

	indexType := "INDEX"
	if idx.IsUnique {
		indexType = "UNIQUE INDEX"
	}

	quotedColumns := make([]string, len(idx.Columns))
	for i, col := range idx.Columns {
		quotedColumns[i] = quoteIdentifier(col)
	}

	return fmt.Sprintf("CREATE %s %s ON %s.%s (%s);\n",
		indexType,
		quoteIdentifier(idx.Name),
		quoteIdentifier(schemaName),
		quoteIdentifier(tableName),
		strings.Join(quotedColumns, ", "))
}

func (p PostgreSQLDDL) DropIndexSQL(schemaName, tableName string, idx models.IndexInfo) string {
	if idx.IsPrimary {
		return fmt.Sprintf("ALTER TABLE %s.%s DROP CONSTRAINT %s;\n",
			quoteIdentifier(schemaName),
			quoteIdentifier(tableName),
			quoteIdentifier(idx.Name))
	}
	return fmt.Sprintf("DROP INDEX %s;\n", quoteIdentifier(idx.Name))
}

func (p PostgreSQLDDL) DropTableSQL(schemaName, tableName string) string {
	return fmt.Sprintf("DROP TABLE %s.%s;\n", quoteIdentifier(schemaName), quoteIdentifier(tableName))
}

func quoteIdentifier(name string) string {
	return fmt.Sprintf("\"%s\"", name)
}

func joinIdentifiers(cols []string) string {
	var parts []string
	for _, col := range cols {
		parts = append(parts, quoteIdentifier(col))
	}
	return strings.Join(parts, ", ")
}

func (p PostgreSQLDDL) AddForeignKeySQL(schemaName, table string, fk models.ForeignKeyInfo) string {
	cols := joinIdentifiers(fk.Columns)
	refCols := joinIdentifiers(fk.ReferencedColumns)

	return fmt.Sprintf(`ALTER TABLE %s.%s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s.%s (%s) ON DELETE %s ON UPDATE %s;`,
		quoteIdentifier(schemaName),
		quoteIdentifier(table),
		quoteIdentifier(fk.Name),
		cols,
		quoteIdentifier(schemaName), // TODO: use fk.ReferencedSchema if available
		quoteIdentifier(fk.ReferencedTable),
		refCols,
		fk.OnDelete,
		fk.OnUpdate)
}

func (p PostgreSQLDDL) DropForeignKeySQL(schemaName, table, constraint string) string {
	return fmt.Sprintf("ALTER TABLE %s.%s DROP CONSTRAINT %s;\n", quoteIdentifier(schemaName), quoteIdentifier(table), quoteIdentifier(constraint))
}

func (p PostgreSQLDDL) DumpDatabaseSQL(connection models.DBConnection, db *gorm.DB) (string, error) {
	var out bytes.Buffer
	var stderr bytes.Buffer
	pass, err := utils.Decrypt([]byte([]byte(os.Getenv("ENCRYPTION_KEY"))), connection.Password)
	if err != nil {
		return "", fmt.Errorf("failed to decrypt password: %v", err)
	}

	pgDumpPath, err := getPgDumpPath()
	if err != nil {
		return "", fmt.Errorf("failed to get pg_dump path: %v", err)
	}

	err = os.Setenv("PGPASSWORD", pass) // Set the password for pg_dump
	if err != nil {
		return "", fmt.Errorf("failed to set PGPASSWORD: %v", err)
	}

	cmd := exec.Command(pgDumpPath,
		"-h", connection.Host,
		"-U", connection.User,
		"-d", connection.DBName,
		"-F", "plain", // plain SQL format
	)
	cmd.Stdout = &out
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("pg_dump failed: %v - %s", err, stderr.String())
	}

	return out.String(), nil
}

func getPgDumpPath() (string, error) {
	// Check the OS using runtime.GOOS
	switch runtime.GOOS {
	case "windows":
		// Windows-specific path to pg_dump
		// Assuming pg_dump is installed with PostgreSQL (e.g., C:\Program Files\PostgreSQL\12\bin)
		// You can update this to your actual installation path
		return "C:\\Program Files\\PostgreSQL\\17\\bin\\pg_dump.exe", nil
	case "darwin":
		// MacOS - installed via Homebrew (default location)
		return "/usr/local/bin/pg_dump", nil
	case "linux":
		// Linux - typically available via package manager
		// Just check if it's in the system path
		return "pg_dump", nil
	default:
		return "", fmt.Errorf("unsupported operating system: %s", runtime.GOOS)
	}
}
